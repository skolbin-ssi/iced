// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

#if MASM
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using Iced.Intel;
using Xunit;

namespace Iced.UnitTests.Intel.FormatterTests.Masm {
	// GENERATOR-BEGIN: SymbolTestFlags
	// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	[Flags]
	enum SymbolTestFlags {
		None = 0x00000000,
		/// <summary>Symbol is found</summary>
		Symbol = 0x00000001,
		/// <summary>Signed symbol</summary>
		Signed = 0x00000002,
		/// <summary><c>options.MasmSymbolDisplInBrackets</c></summary>
		SymbolDisplInBrackets = 0x00000004,
		/// <summary><c>options.MasmDisplInBrackets</c></summary>
		DisplInBrackets = 0x00000008,
		/// <summary><c>options.RipRelativeAddresses</c></summary>
		Rip = 0x00000010,
		/// <summary><c>options.ShowZeroDisplacements</c></summary>
		ShowZeroDisplacements = 0x00000020,
		/// <summary><c>!options.MasmAddDsPrefix32</c></summary>
		NoAddDsPrefix32 = 0x00000040,
	}
	// GENERATOR-END: SymbolTestFlags

	readonly struct SymbolOptionsTestCase {
		public readonly string HexBytes;
		public readonly int Bitness;
		public readonly ulong IP;
		public readonly string FormattedString;
		public readonly SymbolTestFlags Flags;

		public SymbolOptionsTestCase(string hexBytes, int bitness, ulong ip, string formattedString, SymbolTestFlags flags) {
			HexBytes = hexBytes;
			Bitness = bitness;
			IP = ip;
			FormattedString = formattedString;
			Flags = flags;
		}
	}

	static class SymbolOptionsTestsReader {
		static class Dicts {
			// GENERATOR-BEGIN: Dicts
			// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
			internal static readonly Dictionary<string, SymbolTestFlags> ToSymbolTestFlags = new Dictionary<string, SymbolTestFlags>(7, StringComparer.Ordinal) {
				{ "sym", SymbolTestFlags.Symbol },
				{ "signed", SymbolTestFlags.Signed },
				{ "symbr", SymbolTestFlags.SymbolDisplInBrackets },
				{ "displbr", SymbolTestFlags.DisplInBrackets },
				{ "rip", SymbolTestFlags.Rip },
				{ "disp0", SymbolTestFlags.ShowZeroDisplacements },
				{ "nods32", SymbolTestFlags.NoAddDsPrefix32 },
			};
			// GENERATOR-END: Dicts
		}

		public static IEnumerable<SymbolOptionsTestCase> ReadFile(string filename) {
			Debug.Assert(File.Exists(filename));
			int lineNo = 0;
			foreach (var line in File.ReadLines(filename)) {
				lineNo++;
				if (line.Length == 0 || line[0] == '#')
					continue;

				SymbolOptionsTestCase? tc;
				try {
					tc = ParseLine(line);
				}
				catch (Exception ex) {
					throw new Exception($"Invalid line {lineNo} ({filename}): {ex.Message}");
				}
				if (tc.HasValue)
					yield return tc.GetValueOrDefault();
			}

		}

		static readonly char[] commaSeparator = new char[] { ',' };
		static readonly char[] spaceSeparator = new char[] { ' ' };
		static SymbolOptionsTestCase? ParseLine(string line) {
			var elems = line.Split(commaSeparator);
			if (elems.Length != 5)
				throw new Exception($"Invalid number of commas: {elems.Length - 1}");

			var hexBytes = elems[0].Trim();
			if (CodeUtils.IsIgnored(elems[1].Trim()))
				return null;
			var bitness = NumberConverter.ToInt32(elems[2].Trim());
			var ip = bitness switch {
				16 => DecoderConstants.DEFAULT_IP16,
				32 => DecoderConstants.DEFAULT_IP32,
				64 => DecoderConstants.DEFAULT_IP64,
				_ => throw new InvalidOperationException(),
			};
			var formattedString = elems[3].Trim().Replace('|', ',');
			var flags = SymbolTestFlags.None;
			foreach (var value in elems[4].Split(spaceSeparator, StringSplitOptions.RemoveEmptyEntries)) {
				if (!Dicts.ToSymbolTestFlags.TryGetValue(value, out var f))
					throw new InvalidOperationException($"Invalid flags value: {value}");
				flags |= f;
			}
			return new SymbolOptionsTestCase(hexBytes, bitness, ip, formattedString, flags);
		}
	}

	public sealed class SymbolOptionsTests {
		sealed class SymbolResolver : ISymbolResolver {
			readonly SymbolTestFlags flags;

			public SymbolResolver(SymbolTestFlags flags) => this.flags = flags;

			public bool TryGetSymbol(in Instruction instruction, int operand, int instructionOperand, ulong address, int addressSize, out SymbolResult symbol) {
				if (instructionOperand == 1 && (flags & SymbolTestFlags.Symbol) != 0) {
					symbol = new SymbolResult(address, "symbol", FormatterTextKind.Data,
						(flags & SymbolTestFlags.Signed) != 0 ? SymbolFlags.Signed : SymbolFlags.None);
					return true;
				}
				symbol = default;
				return false;
			}
		}

		[Theory]
		[MemberData(nameof(TestIt_Data))]
		void TestIt(string hexBytes, int bitness, ulong ip, string formattedString, SymbolTestFlags flags) {
			var decoder = Decoder.Create(bitness, new ByteArrayCodeReader(hexBytes));
			decoder.IP = ip;
			decoder.Decode(out var instruction);

			var formatter = FormatterFactory.Create_Resolver(new SymbolResolver(flags)).formatter;
			formatter.Options.MasmSymbolDisplInBrackets = (flags & SymbolTestFlags.SymbolDisplInBrackets) != 0;
			formatter.Options.MasmDisplInBrackets = (flags & SymbolTestFlags.DisplInBrackets) != 0;
			formatter.Options.RipRelativeAddresses = (flags & SymbolTestFlags.Rip) != 0;
			formatter.Options.ShowZeroDisplacements = (flags & SymbolTestFlags.ShowZeroDisplacements) != 0;
			formatter.Options.MasmAddDsPrefix32 = (flags & SymbolTestFlags.NoAddDsPrefix32) == 0;

			var output = new StringOutput();
			formatter.Format(instruction, output);
			var actualFormattedString = output.ToStringAndReset();
#pragma warning disable xUnit2006 // Do not use invalid string equality check
			// Show the full string without ellipses by using Equal<string>() instead of Equal()
			Assert.Equal<string>(formattedString, actualFormattedString);
#pragma warning restore xUnit2006 // Do not use invalid string equality check
		}
		public static IEnumerable<object[]> TestIt_Data {
			get {
				var filename = PathUtils.GetTestTextFilename("SymbolOptions.txt", "Formatter", "Masm");
				foreach (var tc in SymbolOptionsTestsReader.ReadFile(filename))
					yield return new object[5] { tc.HexBytes, tc.Bitness, tc.IP, tc.FormattedString, tc.Flags };
			}
		}
	}
}
#endif
